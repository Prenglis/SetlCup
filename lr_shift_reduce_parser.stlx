class srParser(actionTable, gotoTable, stateTable, rulesMap, silent_mode) {
    mActionTable := actionTable;
    mGotoTable   := gotoTable;
    mStateTable  := stateTable;
    mRulesMap := rulesMap;
    mSilentMode := silent_mode;
    parseSR := procedure(tl) {
        action_code := [];
        //init vars
        marked_rules := +/range(mStateTable);
        rule_vars := {mr.mAlpha : mr in marked_rules | mr.mAlpha != []};
        rule_vars := +/rule_vars;
        rule_vars := {  args(rule_var)[2] : rule_var in rule_vars | args(rule_var)[2] != ""};
        action_code += ["result := [];"];
        for(var_id in rule_vars)
        {
            action_code += ["$var_id$ := [];"];
        }
        index   := 1;      // point to next token
        symbols := [];     // stack of symbols
        //find startState
        startState := {x : x in domain(mStateTable) | exists(y in mStateTable[x]| y.mVariable == Var("S", "") && y.mAlpha == [])};
        if(!mSilentMode)
        {
            print("#startState : $#startState$");
        }
        assert(#startState == 1, "multiple States contain S -> (*)");
        startState := arb(startState);
        if(!mSilentMode)
        {
            print("startState : $startState$");
        }
        states  := [startState];
        while (true) {      
            q := states[-1];
            [t_value, t] := tl[index];
            token_id := "";
            //Tokens should have correct ID depending on current state
            //First: Calculate Token_ids which can be used in current State, and following States
            //Second: Only try States corresponding to Token_ids, where mBeta is not empty
            //Third: If there are multiple Token_ids the one should be used, where the FollowSet contains the following Token
            //Fourth: If there is no Token_id which fulfilles the stated rules, the one is Taken where both the FollowSet is empty and the following tokens are empty
            action_tokens := { [args(t_token)[2], mStateTable[shiftState]] : [t_states, t_token ] in domain(mActionTable), shiftState in mActionTable[t_states, t_token] | t_states == q && args(t_token)[1] == t && mStateTable[shiftState] != om};
            action_tokens := {[token_list, { args(x.mBeta[1])[1] : x in followTokens | x.mBeta != []}] : [token_list, followTokens] in action_tokens};
            token_list := domain(action_tokens);
            if(#token_list>0)
            {
                if(#token_list > 1)
                {
                    token_list := [identifier : [identifier, follow_tokens] in action_tokens | (follow_tokens * {tl[index+1][2]} != {}) ];
                    if(#token_list == 0)
                    {
                        token_list := [identifier : [identifier, follow_tokens] in action_tokens | (follow_tokens * {tl[index+1][2]} == {} && follow_tokens =={})];
                    }
                } 
                if(!mSilentMode)
                {
                    print("token_list :$token_list$");               
                }
                assert(#token_list == 1, "Only one Possible Action for Token in State");
                token_id := arb(token_list);                
                if(token_id != "")
                {
                        action_code += ["$token_id$ += ['$t_value$'];"];
                }
            }
            t := Token(t, token_id);             
            t_rest := [ y : [x,y] in tl[index..]];
            if(!mSilentMode)
            {
                print("states:  [ $join(states, \", \")$ ]");
                print("symbols: $join(symbols, \" \")$ | $join(t_rest, \" \")$");
                print("state:   { $join(mStateTable[q], \"\")$ }");
            }
            p := mActionTable[q,t];
            match (p) {
            case om: 
                if(!mSilentMode)
                {
                     print("action($q$, $t$) undefined.");
                     print("Syntax error!\n");
                }
                 return false;
            case Shift(s):
                if(!mSilentMode)
                {
                     print("shifting state $s$");
                     print("state:   { $join(mStateTable[s], \"\")$ }\n");
                }
                 symbols := symbols + [t];
                 states  := states  + [s];
                 index   += 1;
            case Reduce(ruleName):
                 rule := mRulesMap[ruleName];
                 [head, body , user_code] := args(rule);
                 if(!mSilentMode)
                {
                    print("reducing with rule $ruleName$ : $head$ -> $join(body, \" \")$");
                }
                //When the User_Code is  not empty, it is appended to a temporary list of commands which will be executed later on
                //As there might be multiple instances of the Rules which need to be reduced the variables are saved in a Stack-like structure
                // e.g. t_expr := [2 , 3 , Plus(4,5)];
                // the rule-id will be replaced with the last index of the list
                // expr := t_expr[-1] := Plus(4,5);
                // afterwards the item will be removed from the list
                if(user_code == UserCode("") || user_code == UserCode(@'') || args(user_code)[1] == @'' || args(user_code)[1] == "" || #args(user_code)[1] == 0)
                 {
                    
                    
                 }
                 else
                 {
                    vars := {args(variable)[2] : variable in body | args(variable)[2] != ""};
                    for(t_vars in vars)
                    {
                        action_code += ["t_$t_vars$ := $t_vars$;"];
                        action_code += ["$t_vars$ := $t_vars$[-1];"];
                    }
                    action_code := action_code + [args(user_code)[1]];
                    for(t_vars in vars)
                    {
                        action_code += ["$t_vars$ := t_$t_vars$[..-2];"];
                    }
                 }
                 n       := #body;
                 symbols := symbols[.. -(n+1)];
                 states  := states[.. -(n+1)]; 
                 symbols := symbols + [head];
                 state   := states[-1];
                 newStates := mGotoTable[state, head];
                 states  := states + [ newStates ];
                 stateString := mStateTable[newStates];
                 var_id := [];
                 // The id of the Rule-Variable is calculated from the StateTable where the Variable-name is the same as the one from the Rule-head and the where additionally the ID is not empty.
                 // If there is more than one, the following are selected:
                 // The ones, where Alpha (the Tokens before the (*) marker) is not empty and
                 // either: the tokens after the marker are not empty and there are still tokens to read and the first element from Beta is the next token to be read
                 // or: it is the last sign to be read and Beta is empty
                 // or: the following symbol is not in the the FollowTokens of the rule andmBeta is not empty
                 // The conjunction of both sets is made afterwards.
                 var_id := {args(mr.mAlpha[-1])[2] : mr in mStateTable[newStates]| (mr.mAlpha != []) && ( args(mr.mAlpha[-1])[1] == args(head)[1]) && args(mr.mAlpha[-1])[2] != ""};
                 if(#var_id > 1)
                 {
                    alt_ids := { args(mr.mAlpha[-1])[2] : mr in mStateTable[newStates] | mr.mAlpha != [] && ((mr.mBeta != [] &&  ( ( #tl>index &&  args(mr.mBeta[1])[1] == tl[index][2] )))  || ( #tl == index && mr.mBeta ==[]) || (mr.mBeta ==[] && mr.mFollowSet * {tl[index][2]} != {})) };
                    var_id := var_id * alt_ids;                    

                 }
                 if(!mSilentMode)
                {
                    print("stateString : $stateString$");
                    print("var_id : $var_id$");
                }
                 if(#var_id > 0)
                 {
                    assert(#var_id ==1, "only one variable id should be used for one reduction");
                    if(!mSilentMode)
                    {
                        print("var_id : $var_id$");
                    }
                    action_code := action_code + ["$arb(var_id)$ += [result];"];
                 }
                 if(!mSilentMode)
                 {  
                    print("state:   { $join(mStateTable[mGotoTable[state, head]], \"\")$ }\n");
                }
            case Accept():
                 if(!mSilentMode)
                 { 
                    print("accepting\n");
                 }
                 writeFile("temp_action_code.stlx", action_code);

                 return true;
            } 
        }
    };
}
myParse := closure(ruleNames, rulesMap, stateTable, actionTable, gotoTable, silent_mode) {
    parser := srParser(actionTable, gotoTable, stateTable, rulesMap, silent_mode);
    tl := scan_output;
    if(!silent_mode)
    {
        print("tokenlist: $tl$\n");
    }
    if (parser.parseSR(tl + [[@"$", @"$"]])) {
        if(!silent_mode)
        {
            print("Parse successful!");
        }
        try {
            load("temp_action_code.stlx");
        }
        catch(e)
        {
            print("Exception while executing action code : $e$");
        }
        return result;
    } else {
        print("Parse failed!");
    }
};
