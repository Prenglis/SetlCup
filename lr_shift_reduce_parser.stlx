class srParser(actiontable, gototable, statetable, rulesMap, silent_mode) {
    mActiontable := actiontable;
    mGototable   := gototable;
    mStatetable  := statetable;
    scup_mrulesMap := rulesMap;
    mSilentMode := silent_mode;
    parseSR := procedure(scup_tl) {
        // print("statetable := $mStatetable$");
        scup_action_code := [];
        //init scup_vars
        scup_marked_rules := +/range(mStatetable);
        scup_scup_rule_scup_vars := {scup_mr.mAlpha : scup_mr in scup_marked_rules | scup_mr.mAlpha != []};
        scup_scup_rule_scup_vars := +/scup_scup_rule_scup_vars;
        scup_scup_rule_scup_vars := {  args(scup_rule_var)[2] : scup_rule_var in scup_scup_rule_scup_vars | args(scup_rule_var)[2] != ""};
        scup_action_code := "result := [];";
        if(!mSilentMode)
        {
            print("Executing command: $scup_action_code$");
        }
        execute(scup_action_code);
        // scup_action_code += ["result := [];"];
        for(scup_var_id in scup_scup_rule_scup_vars)
        {
            scup_action_code := "$scup_var_id$ := [];";
            if(!mSilentMode)
            {
                print("Executing command: $scup_action_code$");
            }
            execute(scup_action_code);
            // scup_action_code += ["$scup_var_id$ := [];"];
        }
        scup_index   := 1;      // point to next token
        scup_symbols := [];     // stack of scup_symbols
        //find scup_startState
        scup_startState := {startState : startState in domain(mStatetable) | exists(firstState in mStatetable[startState]| firstState.mVariable == Var("S", "") && firstState.mAlpha == [])};
        if(!mSilentMode)
        {
            print("#scup_startState : $#scup_startState$");
        }
        assert(#scup_startState == 1, "multiple scup_states contain S -> (*)");
        scup_startState := arb(scup_startState);
        if(!mSilentMode)
        {
            print("scup_startState : $scup_startState$");
        }
        scup_states  := [scup_startState];
        while (true) {      
            scup_q := scup_states[-1];
            if(!mSilentMode)
            {
                print("scup_q :$scup_q$"); 
                print("scup_tl : $scup_tl$");
            }
            [scup_t_value, scup_t] := scup_tl[scup_index];
            scup_token_id := "";
            //tokens should have correct ID depending on current state
            //First: Calculate scup_token_ids which can be used in current State, and following scup_states
            //Second: Only try scup_states corresponding to scup_token_ids, where mBeta is not empty
            //third: If there are multiple scup_token_ids the one should be used, where the FollowSet contains the following token
            //Fourth: If there is no scup_token_id which fulfilles the stated rules, the one is taken where both the FollowSet is empty and the following tokens are empty
            scup_action_tokens := { [args(scup_t_token)[2], mStatetable[shiftState]] : [scup_t_states, scup_t_token ] in domain(mActiontable), shiftState in mActiontable[scup_t_states, scup_t_token] | scup_t_states == scup_q && args(scup_t_token)[1] == scup_t && mStatetable[shiftState] != om};
            if(!mSilentMode)
            {
                print("scup_action_tokens :$scup_action_tokens$");               
            }
            scup_action_tokens := {[scup_token_list, { args(x.mBeta[1])[1] : x in followtokens | x.mBeta != []}] : [scup_token_list, followtokens] in scup_action_tokens};
            if(!mSilentMode)
            {
                print("scup_action_tokens :$scup_action_tokens$");               
            }
            scup_token_list := domain(scup_action_tokens);
            if(!mSilentMode)
            {
                print("scup_token_list :$scup_token_list$");               
            }
            if(#scup_token_list>0)
            {
                if(#scup_token_list > 1)
                {
                    scup_token_list := [identifier : [identifier, follow_tokens] in scup_action_tokens | (follow_tokens * {scup_tl[scup_index+1][2]} != {}) ];
                    if(#scup_token_list == 0)
                    {
                        scup_token_list := [identifier : [identifier, follow_tokens] in scup_action_tokens | (follow_tokens * {scup_tl[scup_index+1][2]} == {} && follow_tokens =={})];
                    }
                } 
                if(!mSilentMode)
                {
                    print("scup_token_list :$scup_token_list$");               
                }
                assert(#scup_token_list == 1, "Only one Possible Action for token in State");
                scup_token_id := arb(scup_token_list);                
                if(scup_token_id != "")
                {
                        // scup_action_code += ["$scup_token_id$ += ['$scup_t_value$'];"];
                        scup_action_code := "$scup_token_id$ += ['$scup_t_value$'];";
                        if(!mSilentMode)
                        {
                            print("Executing command: $scup_action_code$");
                        }
                        execute(scup_action_code);
                }
            }
            scup_t := Token(scup_t , scup_token_id);             
            scup_t_rest := [ y : [x,y] in scup_tl[scup_index..]];
            if(!mSilentMode)
            {
                print("scup_states:  [ $join(scup_states, \", \")$ ]");
                print("scup_symbols: $join(scup_symbols, \" \")$ | $join(scup_t_rest, \" \")$");
                print("state:   { $join(mStatetable[scup_q], \"\")$ }");
                print("scup_q,scup_t : $scup_q$,$scup_t$");
            }
            scup_p := mActiontable[scup_q,scup_t];
            if(!mSilentMode)
            {
                  print("scup_p := mActiontable[scup_q,scup_t]-----$scup_p$ := $mActiontable[scup_q,scup_t]$");
            }
            match (scup_p) {
            case om: 
                if(!mSilentMode)
                {
                     print("action($scup_q$, $scup_t$) undefined.");
                     print("Syntax error!\n");
                }
                 return false;
            case Shift(scup_s):
                if(!mSilentMode)
                {
                     print("shifting state $scup_s$");
                     print("state:   { $join(mStatetable[scup_s], \"\")$ }\n");
                }
                 scup_symbols := scup_symbols + [scup_t];
                 scup_states  := scup_states  + [scup_s];
                 scup_index   += 1;
            case Reduce(ruleName):
                 rule := scup_mrulesMap[ruleName];
                 [head, body , scup_user_code] := args(rule);
                 if(!mSilentMode)
                {
                    print("reducing with rule $ruleName$ : $head$ -> $join(body, \" \")$");
                }
                //When the scup_user_code is  not empty, it is appended to a temporary list of commands which will be executed later on
                //As there might be multiple instances of the Rules which need to be reduced the variables are saved in a Stack-like structure
                // e.g. t_expr := [2 , 3 , Plus(4,5)];
                // the rule-id will be replaced with the last scup_index of the list
                // expr := t_expr[-1] := Plus(4,5);
                // afterwards the item will be removed from the list
                if(scup_user_code == UserCode("") || scup_user_code == UserCode(@'') || args(scup_user_code)[1] == @'' || args(scup_user_code)[1] == "" || #args(scup_user_code)[1] == 0)
                 {
                    
                    
                 }
                 else
                 {
                    scup_vars := {args(variable)[2] : variable in body | args(variable)[2] != ""};
                    for(t_scup_vars in scup_vars)
                    {
                        scup_action_code :="t_$t_scup_vars$ := $t_scup_vars$;";
                        if(!mSilentMode)
                        {
                            print("Executing command: $scup_action_code$");
                        }
                        execute(scup_action_code);
                        scup_action_code := "$t_scup_vars$ := $t_scup_vars$[-1];";
                        if(!mSilentMode)
                        {
                            print("Executing command: $scup_action_code$");
                        }
                        execute(scup_action_code);
                        // scup_action_code += ["t_$t_scup_vars$ := $t_scup_vars$;"];
                        // scup_action_code += ["$t_scup_vars$ := $t_scup_vars$[-1];"];
                    }
                    scup_action_code := args(scup_user_code)[1];
                    if(!mSilentMode)
                    {
                        print("Executing command: $scup_action_code$");
                    }
                    execute(scup_action_code);
                    // scup_action_code := scup_action_code + [args(scup_user_code)[1]];

                    for(t_scup_vars in scup_vars)
                    {
                        scup_action_code := "$t_scup_vars$ := t_$t_scup_vars$[..-2];";
                        if(!mSilentMode)
                        {
                            print("Executing command: $scup_action_code$");
                        }
                        execute(scup_action_code);
                        // scup_action_code += ["$t_scup_vars$ := t_$t_scup_vars$[..-2];"];
                    }
                 }
                 scup_n       := #body;
                 scup_symbols := scup_symbols[.. -(scup_n+1)];
                 scup_states  := scup_states[.. -(scup_n+1)]; 
                 scup_symbols := scup_symbols + [head];
                 state   := scup_states[-1];
                 scup_new_states := mGototable[state, head];
                 scup_states  := scup_states + [ scup_new_states ];
                 scup_statestring := mStatetable[scup_new_states];
                 scup_var_id := [];
                 // the id of the Rule-Variable is calculated from the Statetable where the Variable-name is the same as the one from the Rule-head and the where additionally the ID is not empty.
                 // If there is more than one, the following are selected:
                 // the ones, where Alpha (the tokens before the (*) marker) is not empty and
                 // either: the tokens after the marker are not empty and there are still tokens to read and the first element from Beta is the next token to be read
                 // or: it is the last sign to be read and Beta is empty
                 // or: the following symbol is not in the the Followtokens of the rule andmBeta is not empty
                 // the conjunction of both sets is made afterwards.
                 scup_var_id := {args(scup_mr.mAlpha[-1])[2] : scup_mr in mStatetable[scup_new_states]| (scup_mr.mAlpha != []) && ( args(scup_mr.mAlpha[-1])[1] == args(head)[1]) && args(scup_mr.mAlpha[-1])[2] != ""};
                 if(#scup_var_id > 1)
                 {
                    scup_alt_ids := { args(scup_mr.mAlpha[-1])[2] : scup_mr in mStatetable[scup_new_states] | scup_mr.mAlpha != [] && ((scup_mr.mBeta != [] &&  ( ( #scup_tl>scup_index &&  args(scup_mr.mBeta[1])[1] == scup_tl[scup_index][2] )))  || ( #scup_tl == scup_index && scup_mr.mBeta ==[]) || (scup_mr.mBeta ==[] && scup_mr.mFollowSet * {scup_tl[scup_index][2]} != {})) };
                    scup_var_id := scup_var_id * scup_alt_ids;                    

                 }
                 if(!mSilentMode)
                {
                    print("scup_statestring : $scup_statestring$");
                    print("scup_var_id : $scup_var_id$");
                }
                 if(#scup_var_id > 0)
                 {
                    assert(#scup_var_id ==1, "only one variable id should be used for one reduction");
                    if(!mSilentMode)
                    {
                        print("scup_var_id : $scup_var_id$");
                    }
                    scup_action_code := "$arb(scup_var_id)$ += [result];";
                    if(!mSilentMode)
                    {
                        print("Executing command: $scup_action_code$");
                    }
                    execute(scup_action_code);
                    // scup_action_code := scup_action_code + ["$arb(scup_var_id)$ += [result];"];
                 }
                 if(!mSilentMode)
                 {  
                    print("state:   { $join(mStatetable[mGototable[state, head]], \"\")$ }\n");
                }
            case Accept():
                 if(!mSilentMode)
                 { 
                    print("accepting\n");
                 }
                 // writeFile("temp_scup_action_code.sscup_tlx", scup_action_code);

                 return result;
            } 
        }
    };

    executeActionCode := procedure(scup_action_code)
    {
        if(!mSilentMode)
        {
            print("Executing command: $scup_action_code$");
        }
        execute(scup_action_code);
    };
}
myParse := closure(ruleNames, rulesMap, statetable, actiontable, gototable, silent_mode) {
    parser := srParser(actiontable, gototable, statetable, rulesMap, silent_mode);
    scup_tl := scan_output;
    if(!silent_mode)
    {
        print("tokenlist: $scup_tl$\n");
    }
    result := parser.parseSR(scup_tl + [[@"$", @"$"]]);
    // if (parser.parseSR(scup_tl + [[@"$", @"$"]])) {
        // if(!silent_mode)
        // {
            // print("Parse successful!");
        // }
        // try {
            // load("temp_scup_action_code.sscup_tlx");
        // }
        // catch(e)
        // {
            // print("Exception while executing action code : $e$");
        // }
        return result;
    // } else {
        // print("Parse failed!");
    // }
};
