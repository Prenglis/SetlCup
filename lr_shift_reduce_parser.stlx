class srParser(actionTable, gotoTable, stateTable, rulesMap, silent_mode) {
    mActionTable := actionTable;
    mGotoTable   := gotoTable;
    mStateTable  := stateTable;
    mRulesMap := rulesMap;
    mSilentMode := silent_mode;
    parseSR := procedure(tl) {
        action_code := [];
        //init vars
        mrs := +/range(mStateTable);
        vars := {mr.mAlpha : mr in mrs | mr.mAlpha != []};
        vars := +/vars;
        vars := {  args(mvars)[2] : mvars in vars | args(mvars)[2] != ""};
        action_code += ["result := [];"]
        for(var_id in vars)
        {
            action_code += ["$var_id$ := [];"];
        }
        index   := 1;      // point to next token
        symbols := [];     // stack of symbols
        startState := {x : x in domain(mStateTable) | exists(y in mStateTable[x]| y.mVariable == Var("S", "") && y.mAlpha == [])};
        if(!mSilentMode)
        {
            print("#startState : $#startState$");
        }
        assert(#startState == 1, "multiple States contain S -> (*)");
        startState := arb(startState);
        if(!mSilentMode)
        {
            print("startState : $startState$");
        }
        states  := [startState];
        while (true) {      
            q := states[-1];
            [t_value, t] := tl[index];
            token_id := "";
            action_tokens := { [args(t_token)[2], mStateTable[shiftState]] : [t_states, t_token ] in domain(mActionTable), shiftState in mActionTable[t_states, t_token] | t_states == q && args(t_token)[1] == t && mStateTable[shiftState] != om};
            action_tokens := {[token_list, { args(x.mBeta[1])[1] : x in followTokens | x.mBeta != []}] : [token_list, followTokens] in action_tokens};
                token_list := domain(action_tokens);
                if(#token_list>0)
                {
                    if(#token_list > 1)
                    {
                        token_list := [x : [x, ft] in action_tokens | (ft * {tl[index+1][2]} != {}) ];
                        if(#token_list == 0)
                        {
                            token_list := [x : [x, ft] in action_tokens | (ft * {tl[index+1][2]} == {} && ft =={})];
                        }
                    } 
                    if(!mSilentMode)
                    {
                        print("token_list :$token_list$");               
                    }
                    assert(#token_list == 1, "Only one Possible Action for Token in State");
                    token_id := arb(token_list);                
                    if(token_id != "")
                    {
                            action_code += ["$token_id$ += ['$t_value$'];"];
                    }
                }
            t := Token(t, token_id);             
            t_rest := [ y : [x,y] in tl[index..]];
            if(!mSilentMode)
            {
                print("states:  [ $join(states, \", \")$ ]");
                print("symbols: $join(symbols, \" \")$ | $join(t_rest, \" \")$");
                print("state:   { $join(mStateTable[q], \"\")$ }");
            }
            p := mActionTable[q,t];
            match (p) {
            case om: 
                if(!mSilentMode)
                {
                     print("action($q$, $t$) undefined.");
                     print("Syntax error!\n");
                }
                 return false;
            case Shift(s):
                if(!mSilentMode)
                {
                     print("shifting state $s$");
                     print("state:   { $join(mStateTable[s], \"\")$ }\n");
                }
                 symbols := symbols + [t];
                 states  := states  + [s];
                 index   += 1;
            case Reduce(ruleName):
                 rule := mRulesMap[ruleName];
                 [head, body , user_code] := args(rule);
                 if(!mSilentMode)
                {
                    print("reducing with rule $ruleName$ : $head$ -> $join(body, \" \")$");
                }
                if(user_code == UserCode("") || user_code == UserCode(@'') || args(user_code)[1] == @'' || args(user_code)[1] == "" || #args(user_code)[1] == 0)
                 {
                    
                    
                 }
                 else
                 {
                    vars := {args(variable)[2] : variable in body | args(variable)[2] != ""};
                    for(t_vars in vars)
                    {
                        action_code += ["t_$t_vars$ := $t_vars$;"];
                        action_code += ["$t_vars$ := $t_vars$[-1];"];
                    }
                    action_code := action_code + [args(user_code)[1]];
                    for(t_vars in vars)
                    {
                        action_code += ["$t_vars$ := t_$t_vars$[..-2];"];
                    }
                 }
                 n       := #body;
                 symbols := symbols[.. -(n+1)];
                 states  := states[.. -(n+1)]; 
                 symbols := symbols + [head];
                 state   := states[-1];
                 newStates := mGotoTable[state, head];
                 states  := states + [ newStates ];
                 stateString := mStateTable[newStates];
                 var_id := [];
                 var_id := {args(mr.mAlpha[-1])[2] : mr in mStateTable[newStates]| (mr.mAlpha != []) && ( args(mr.mAlpha[-1])[1] == args(head)[1]) && args(mr.mAlpha[-1])[2] != ""};
                 if(#var_id > 1)
                 {
                    alt_ids := { args(mr.mAlpha[-1])[2] : mr in mStateTable[newStates] | mr.mAlpha != [] && ((mr.mBeta != [] &&  ( ( #tl>index &&  args(mr.mBeta[1])[1] == tl[index][2] )))  || ( #tl == index && mr.mBeta ==[]) || (mr.mBeta ==[] && mr.mFollowSet * {tl[index][2]} != {})) };
                    var_id := var_id * alt_ids;
                    if(#var_id == 0)
                    {
                        var_id := { args(mr.mAlpha[1])[2] : mr in mStateTable[newStates] | mr.mAlpha != [] && mr.mBeta != [] &&  args(mr.mBeta[1])[1] == tl[index][2] };

                    }
                    

                 }
                 if(!mSilentMode)
                {
                    print("stateString : $stateString$");
                    print("var_id : $var_id$");
                }
                 if(#var_id > 0)
                 {
                    assert(#var_id ==1, "only one variable id should be used for one reduction");
                    if(!mSilentMode)
                    {
                        print("var_id : $var_id$");
                    }
                    action_code := action_code + ["$arb(var_id)$ += [result];"];
                 }
                 if(!mSilentMode)
                 {  
                    print("state:   { $join(mStateTable[mGotoTable[state, head]], \"\")$ }\n");
                }
            case Accept():
                 if(!mSilentMode)
                 { 
                    print("accepting\n");
                 }
                 writeFile("temp_action_code.stlx", action_code);

                 return true;
            } 
        }
    };
}
myParse := closure(ruleNames, rulesMap, stateTable, actionTable, gotoTable, silent_mode) {
    parser := srParser(actionTable, gotoTable, stateTable, rulesMap, silent_mode);
    tl := scan_output;
    if(!silent_mode)
    {
        print("tokenlist: $tl$\n");
    }
    if (parser.parseSR(tl + [[@"$", @"$"]])) {
        if(!silent_mode)
        {
            print("Parse successful!");
        }
        load("temp_action_code.stlx");
        return result;
    } else {
        print("Parse failed!");
    }
};

// This procedure partitions the string s into a list of tokens.
// It recognizes numbers, the operator symbols "+", "-", "*", "/", "**"
// and the parentheses "(" and ")".
tokenizeString := procedure(s) {
    tokenList := [];
    scan (s) {
        regex '0|[1-9][0-9]*' as [ number   ]: tokenList += [ "int"    ];
        regex '[-+*/()]'      as [ operator ]: tokenList += [ operator ];
        regex '[ \t\v\n\r]+'                 : // skip
    }
    return tokenList;
};
