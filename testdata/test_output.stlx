arith_expr ::= expr_list:esl {: result := ExprList(esl); :};

expr_list ::= expr_part:part expr_list:l {: result := [part] + l; :} 
           |  {: result := []; :}
           ;
expr_part ::= expr:e SEMICOLON {: result := e; :}
           ;
expr ::= expr:e PLUS   prod:p {: result := Plus(e , p); :} 
      |  expr:e MINUS  prod:p {: result := Minus(e , p); :} 
      |  prod:p               {: result := p;     :}
      ;
prod ::= prod:p TIMES  fact:f {: result := Times(p , f); :}
      |  prod:p DIVIDE fact:f {: result := Div(p , f); :} 
      |  prod:p MOD    fact:f {: result := Mod(p , f); :} 
      |  fact:f               {: result := f;     :}
      ;
fact ::= LPAREN expr:e_part RPAREN {: result :=  e_part ;   :} 
      |  INTEGER:n             {: result := Integer(eval(n)); :} 
      ;
rulesMap := {};
r0 := Rule(Var("arith_expr", ""), [Var("expr_list", "esl")], UserCode(" result := ExprList(esl); "));
rulesMap["r0"] := Rule(Var("arith_expr", ""), [Var("expr_list", "esl")], UserCode(" result := ExprList(esl); "));
r1 := Rule(Var("expr_list", ""), [Var("expr_part", "part"), Var("expr_list", "l")], UserCode(" result := [part] + l; "));
rulesMap["r1"] := Rule(Var("expr_list", ""), [Var("expr_part", "part"), Var("expr_list", "l")], UserCode(" result := [part] + l; "));
r2 := Rule(Var("expr_list", ""), [], UserCode(" result := []; "));
rulesMap["r2"] := Rule(Var("expr_list", ""), [], UserCode(" result := []; "));
r3 := Rule(Var("expr_part", ""), [Var("expr", "e"), Token("SEMICOLON", "")], UserCode(" result := e; "));
rulesMap["r3"] := Rule(Var("expr_part", ""), [Var("expr", "e"), Token("SEMICOLON", "")], UserCode(" result := e; "));
r4 := Rule(Var("expr", ""), [Var("expr", "e"), Token("PLUS", ""), Var("prod", "p")], UserCode(" result := Plus(e , p); "));
rulesMap["r4"] := Rule(Var("expr", ""), [Var("expr", "e"), Token("PLUS", ""), Var("prod", "p")], UserCode(" result := Plus(e , p); "));
r5 := Rule(Var("expr", ""), [Var("expr", "e"), Token("MINUS", ""), Var("prod", "p")], UserCode(" result := Minus(e , p); "));
rulesMap["r5"] := Rule(Var("expr", ""), [Var("expr", "e"), Token("MINUS", ""), Var("prod", "p")], UserCode(" result := Minus(e , p); "));
r6 := Rule(Var("expr", ""), [Var("prod", "p")], UserCode(" result := p;     "));
rulesMap["r6"] := Rule(Var("expr", ""), [Var("prod", "p")], UserCode(" result := p;     "));
r7 := Rule(Var("prod", ""), [Var("prod", "p"), Token("TIMES", ""), Var("fact", "f")], UserCode(" result := Times(p , f); "));
rulesMap["r7"] := Rule(Var("prod", ""), [Var("prod", "p"), Token("TIMES", ""), Var("fact", "f")], UserCode(" result := Times(p , f); "));
r8 := Rule(Var("prod", ""), [Var("prod", "p"), Token("DIVIDE", ""), Var("fact", "f")], UserCode(" result := Div(p , f); "));
rulesMap["r8"] := Rule(Var("prod", ""), [Var("prod", "p"), Token("DIVIDE", ""), Var("fact", "f")], UserCode(" result := Div(p , f); "));
r9 := Rule(Var("prod", ""), [Var("prod", "p"), Token("MOD", ""), Var("fact", "f")], UserCode(" result := Mod(p , f); "));
rulesMap["r9"] := Rule(Var("prod", ""), [Var("prod", "p"), Token("MOD", ""), Var("fact", "f")], UserCode(" result := Mod(p , f); "));
r10 := Rule(Var("prod", ""), [Var("fact", "f")], UserCode(" result := f;     "));
rulesMap["r10"] := Rule(Var("prod", ""), [Var("fact", "f")], UserCode(" result := f;     "));
r11 := Rule(Var("fact", ""), [Token("LPAREN", ""), Var("expr", "e_part"), Token("RPAREN", "")], UserCode(" result :=  e_part ;   "));
rulesMap["r11"] := Rule(Var("fact", ""), [Token("LPAREN", ""), Var("expr", "e_part"), Token("RPAREN", "")], UserCode(" result :=  e_part ;   "));
r12 := Rule(Var("fact", ""), [Token("INTEGER", "n")], UserCode(" result := Integer(eval(n)); "));
rulesMap["r12"] := Rule(Var("fact", ""), [Token("INTEGER", "n")], UserCode(" result := Integer(eval(n)); "));
r13 := Rule(Var("S", ""), [Var("arith_expr", "")], UserCode(""));
rulesMap["r13"] := Rule(Var("S", ""), [Var("arith_expr", "")], UserCode(""));


stateTable := {};
stateTable["s0"] := "{ Var("expr_list", "") -> (*): {\$}, Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("S", "") -> (*) arith_expr: {\$}, Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }, Var("arith_expr", "") -> (*) expr_list:esl: {\$}, Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, },  }";
stateTable["s1"] := "{ Var("expr_list", "") -> (*): {\$}, Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }, Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$},  }";
stateTable["s2"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, RPAREN, }, Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, RPAREN, }, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("expr", "") -> (*) prod:p: {MINUS, PLUS, RPAREN, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> LPAREN (*) expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, },  }";
stateTable["s3"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, RPAREN, }, Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, RPAREN, }, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("expr", "") -> (*) prod:p: {MINUS, PLUS, RPAREN, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> LPAREN (*) expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, },  }";
stateTable["s4"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("expr", "") -> expr:e MINUS (*) prod:p: {MINUS, PLUS, RPAREN, },  }";
stateTable["s5"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, RPAREN, },  }";
stateTable["s6"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p DIVIDE (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, },  }";
stateTable["s7"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p MOD (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, },  }";
stateTable["s8"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p TIMES (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, },  }";
stateTable["s9"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> expr:e MINUS (*) prod:p: {MINUS, PLUS, SEMICOLON, },  }";
stateTable["s10"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, },  }";
stateTable["s11"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p DIVIDE (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, },  }";
stateTable["s12"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p MOD (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, },  }";
stateTable["s13"] := "{ Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p TIMES (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, },  }";
stateTable["s14"] := "{ Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }";
stateTable["s15"] := "{ Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }";
stateTable["s16"] := "{ Var("fact", "") -> LPAREN expr:e_part (*) RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, RPAREN, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, RPAREN, },  }";
stateTable["s17"] := "{ Var("fact", "") -> LPAREN expr:e_part (*) RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, RPAREN, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, RPAREN, },  }";
stateTable["s18"] := "{ Var("fact", "") -> LPAREN expr:e_part RPAREN (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }";
stateTable["s19"] := "{ Var("fact", "") -> LPAREN expr:e_part RPAREN (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }";
stateTable["s20"] := "{ Var("S", "") -> arith_expr (*): {\$} }";
stateTable["s21"] := "{ Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, },  }";
stateTable["s22"] := "{ Var("expr", "") -> expr:e MINUS prod:p (*): {MINUS, PLUS, RPAREN, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, },  }";
stateTable["s23"] := "{ Var("expr", "") -> expr:e MINUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, },  }";
stateTable["s24"] := "{ Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, RPAREN, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, },  }";
stateTable["s25"] := "{ Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, },  }";
stateTable["s26"] := "{ Var("expr_part", "") -> expr:e SEMICOLON (*): {\$, INTEGER, LPAREN, } }";
stateTable["s27"] := "{ Var("arith_expr", "") -> expr_list:esl (*): {\$} }";
stateTable["s28"] := "{ Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$} }";
stateTable["s29"] := "{ Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }";
stateTable["s30"] := "{ Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }";
stateTable["s31"] := "{ Var("expr", "") -> prod:p (*): {MINUS, PLUS, RPAREN, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, },  }";
stateTable["s32"] := "{ Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, },  }";
stateTable["s33"] := "{ Var("prod", "") -> prod:p DIVIDE fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }";
stateTable["s34"] := "{ Var("prod", "") -> prod:p DIVIDE fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }";
stateTable["s35"] := "{ Var("prod", "") -> prod:p MOD fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }";
stateTable["s36"] := "{ Var("prod", "") -> prod:p MOD fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }";
stateTable["s37"] := "{ Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }";
stateTable["s38"] := "{ Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }";

actionTable := {};
actionTable["s0", Token("INTEGER", "n")] := Shift("s15");
actionTable["s0", Token("LPAREN", "")] := Shift("s3");
actionTable["s0", Token("$", "")] := Reduce("r2");

actionTable["s1", Token("INTEGER", "n")] := Shift("s15");
actionTable["s1", Token("LPAREN", "")] := Shift("s3");
actionTable["s1", Token("$", "")] := Reduce("r2");

actionTable["s2", Token("INTEGER", "n")] := Shift("s14");
actionTable["s2", Token("LPAREN", "")] := Shift("s2");

actionTable["s3", Token("INTEGER", "n")] := Shift("s14");
actionTable["s3", Token("LPAREN", "")] := Shift("s2");

actionTable["s4", Token("INTEGER", "n")] := Shift("s14");
actionTable["s4", Token("LPAREN", "")] := Shift("s2");

actionTable["s5", Token("INTEGER", "n")] := Shift("s14");
actionTable["s5", Token("LPAREN", "")] := Shift("s2");

actionTable["s6", Token("INTEGER", "n")] := Shift("s14");
actionTable["s6", Token("LPAREN", "")] := Shift("s2");

actionTable["s7", Token("INTEGER", "n")] := Shift("s14");
actionTable["s7", Token("LPAREN", "")] := Shift("s2");

actionTable["s8", Token("INTEGER", "n")] := Shift("s14");
actionTable["s8", Token("LPAREN", "")] := Shift("s2");

actionTable["s9", Token("INTEGER", "n")] := Shift("s15");
actionTable["s9", Token("LPAREN", "")] := Shift("s3");

actionTable["s10", Token("INTEGER", "n")] := Shift("s15");
actionTable["s10", Token("LPAREN", "")] := Shift("s3");

actionTable["s11", Token("INTEGER", "n")] := Shift("s15");
actionTable["s11", Token("LPAREN", "")] := Shift("s3");

actionTable["s12", Token("INTEGER", "n")] := Shift("s15");
actionTable["s12", Token("LPAREN", "")] := Shift("s3");

actionTable["s13", Token("INTEGER", "n")] := Shift("s15");
actionTable["s13", Token("LPAREN", "")] := Shift("s3");

actionTable["s14", Token("DIVIDE", "")] := Reduce("r12");
actionTable["s14", Token("MINUS", "")] := Reduce("r12");
actionTable["s14", Token("MOD", "")] := Reduce("r12");
actionTable["s14", Token("PLUS", "")] := Reduce("r12");
actionTable["s14", Token("RPAREN", "")] := Reduce("r12");
actionTable["s14", Token("TIMES", "")] := Reduce("r12");

actionTable["s15", Token("DIVIDE", "")] := Reduce("r12");
actionTable["s15", Token("MINUS", "")] := Reduce("r12");
actionTable["s15", Token("MOD", "")] := Reduce("r12");
actionTable["s15", Token("PLUS", "")] := Reduce("r12");
actionTable["s15", Token("SEMICOLON", "")] := Reduce("r12");
actionTable["s15", Token("TIMES", "")] := Reduce("r12");

actionTable["s16", Token("MINUS", "")] := Shift("s4");
actionTable["s16", Token("PLUS", "")] := Shift("s5");
actionTable["s16", Token("RPAREN", "")] := Shift("s18");

actionTable["s17", Token("MINUS", "")] := Shift("s4");
actionTable["s17", Token("PLUS", "")] := Shift("s5");
actionTable["s17", Token("RPAREN", "")] := Shift("s19");

actionTable["s18", Token("DIVIDE", "")] := Reduce("r11");
actionTable["s18", Token("MINUS", "")] := Reduce("r11");
actionTable["s18", Token("MOD", "")] := Reduce("r11");
actionTable["s18", Token("PLUS", "")] := Reduce("r11");
actionTable["s18", Token("RPAREN", "")] := Reduce("r11");
actionTable["s18", Token("TIMES", "")] := Reduce("r11");

actionTable["s19", Token("DIVIDE", "")] := Reduce("r11");
actionTable["s19", Token("MINUS", "")] := Reduce("r11");
actionTable["s19", Token("MOD", "")] := Reduce("r11");
actionTable["s19", Token("PLUS", "")] := Reduce("r11");
actionTable["s19", Token("SEMICOLON", "")] := Reduce("r11");
actionTable["s19", Token("TIMES", "")] := Reduce("r11");

actionTable["s20", Token("$", "")] := Accept();

actionTable["s21", Token("MINUS", "")] := Shift("s9");
actionTable["s21", Token("PLUS", "")] := Shift("s10");
actionTable["s21", Token("SEMICOLON", "")] := Shift("s26");

actionTable["s22", Token("DIVIDE", "")] := Shift("s6");
actionTable["s22", Token("MOD", "")] := Shift("s7");
actionTable["s22", Token("TIMES", "")] := Shift("s8");
actionTable["s22", Token("MINUS", "")] := Reduce("r5");
actionTable["s22", Token("PLUS", "")] := Reduce("r5");
actionTable["s22", Token("RPAREN", "")] := Reduce("r5");

actionTable["s23", Token("DIVIDE", "")] := Shift("s11");
actionTable["s23", Token("MOD", "")] := Shift("s12");
actionTable["s23", Token("TIMES", "")] := Shift("s13");
actionTable["s23", Token("MINUS", "")] := Reduce("r5");
actionTable["s23", Token("PLUS", "")] := Reduce("r5");
actionTable["s23", Token("SEMICOLON", "")] := Reduce("r5");

actionTable["s24", Token("DIVIDE", "")] := Shift("s6");
actionTable["s24", Token("MOD", "")] := Shift("s7");
actionTable["s24", Token("TIMES", "")] := Shift("s8");
actionTable["s24", Token("MINUS", "")] := Reduce("r4");
actionTable["s24", Token("PLUS", "")] := Reduce("r4");
actionTable["s24", Token("RPAREN", "")] := Reduce("r4");

actionTable["s25", Token("DIVIDE", "")] := Shift("s11");
actionTable["s25", Token("MOD", "")] := Shift("s12");
actionTable["s25", Token("TIMES", "")] := Shift("s13");
actionTable["s25", Token("MINUS", "")] := Reduce("r4");
actionTable["s25", Token("PLUS", "")] := Reduce("r4");
actionTable["s25", Token("SEMICOLON", "")] := Reduce("r4");

actionTable["s26", Token("$", "")] := Reduce("r3");
actionTable["s26", Token("INTEGER", "")] := Reduce("r3");
actionTable["s26", Token("LPAREN", "")] := Reduce("r3");

actionTable["s27", Token("$", "")] := Reduce("r0");

actionTable["s28", Token("$", "")] := Reduce("r1");

actionTable["s29", Token("DIVIDE", "")] := Reduce("r10");
actionTable["s29", Token("MINUS", "")] := Reduce("r10");
actionTable["s29", Token("MOD", "")] := Reduce("r10");
actionTable["s29", Token("PLUS", "")] := Reduce("r10");
actionTable["s29", Token("RPAREN", "")] := Reduce("r10");
actionTable["s29", Token("TIMES", "")] := Reduce("r10");

actionTable["s30", Token("DIVIDE", "")] := Reduce("r10");
actionTable["s30", Token("MINUS", "")] := Reduce("r10");
actionTable["s30", Token("MOD", "")] := Reduce("r10");
actionTable["s30", Token("PLUS", "")] := Reduce("r10");
actionTable["s30", Token("SEMICOLON", "")] := Reduce("r10");
actionTable["s30", Token("TIMES", "")] := Reduce("r10");

actionTable["s31", Token("DIVIDE", "")] := Shift("s6");
actionTable["s31", Token("MOD", "")] := Shift("s7");
actionTable["s31", Token("TIMES", "")] := Shift("s8");
actionTable["s31", Token("MINUS", "")] := Reduce("r6");
actionTable["s31", Token("PLUS", "")] := Reduce("r6");
actionTable["s31", Token("RPAREN", "")] := Reduce("r6");

actionTable["s32", Token("DIVIDE", "")] := Shift("s11");
actionTable["s32", Token("MOD", "")] := Shift("s12");
actionTable["s32", Token("TIMES", "")] := Shift("s13");
actionTable["s32", Token("MINUS", "")] := Reduce("r6");
actionTable["s32", Token("PLUS", "")] := Reduce("r6");
actionTable["s32", Token("SEMICOLON", "")] := Reduce("r6");

actionTable["s33", Token("DIVIDE", "")] := Reduce("r8");
actionTable["s33", Token("MINUS", "")] := Reduce("r8");
actionTable["s33", Token("MOD", "")] := Reduce("r8");
actionTable["s33", Token("PLUS", "")] := Reduce("r8");
actionTable["s33", Token("RPAREN", "")] := Reduce("r8");
actionTable["s33", Token("TIMES", "")] := Reduce("r8");

actionTable["s34", Token("DIVIDE", "")] := Reduce("r8");
actionTable["s34", Token("MINUS", "")] := Reduce("r8");
actionTable["s34", Token("MOD", "")] := Reduce("r8");
actionTable["s34", Token("PLUS", "")] := Reduce("r8");
actionTable["s34", Token("SEMICOLON", "")] := Reduce("r8");
actionTable["s34", Token("TIMES", "")] := Reduce("r8");

actionTable["s35", Token("DIVIDE", "")] := Reduce("r9");
actionTable["s35", Token("MINUS", "")] := Reduce("r9");
actionTable["s35", Token("MOD", "")] := Reduce("r9");
actionTable["s35", Token("PLUS", "")] := Reduce("r9");
actionTable["s35", Token("RPAREN", "")] := Reduce("r9");
actionTable["s35", Token("TIMES", "")] := Reduce("r9");

actionTable["s36", Token("DIVIDE", "")] := Reduce("r9");
actionTable["s36", Token("MINUS", "")] := Reduce("r9");
actionTable["s36", Token("MOD", "")] := Reduce("r9");
actionTable["s36", Token("PLUS", "")] := Reduce("r9");
actionTable["s36", Token("SEMICOLON", "")] := Reduce("r9");
actionTable["s36", Token("TIMES", "")] := Reduce("r9");

actionTable["s37", Token("DIVIDE", "")] := Reduce("r7");
actionTable["s37", Token("MINUS", "")] := Reduce("r7");
actionTable["s37", Token("MOD", "")] := Reduce("r7");
actionTable["s37", Token("PLUS", "")] := Reduce("r7");
actionTable["s37", Token("RPAREN", "")] := Reduce("r7");
actionTable["s37", Token("TIMES", "")] := Reduce("r7");

actionTable["s38", Token("DIVIDE", "")] := Reduce("r7");
actionTable["s38", Token("MINUS", "")] := Reduce("r7");
actionTable["s38", Token("MOD", "")] := Reduce("r7");
actionTable["s38", Token("PLUS", "")] := Reduce("r7");
actionTable["s38", Token("SEMICOLON", "")] := Reduce("r7");
actionTable["s38", Token("TIMES", "")] := Reduce("r7");

gotoTable := {};
gotoTable["s0", Var("arith_expr", "")] := "s20";
gotoTable["s0", Var("expr", "")] := "s21";
gotoTable["s0", Var("expr_list", "")] := "s27";
gotoTable["s0", Var("expr_part", "")] := "s1";
gotoTable["s0", Var("fact", "")] := "s30";
gotoTable["s0", Var("prod", "")] := "s32";
gotoTable["s1", Var("expr", "")] := "s21";
gotoTable["s1", Var("expr_list", "")] := "s28";
gotoTable["s1", Var("expr_part", "")] := "s1";
gotoTable["s1", Var("fact", "")] := "s30";
gotoTable["s1", Var("prod", "")] := "s32";
gotoTable["s2", Var("expr", "")] := "s16";
gotoTable["s2", Var("fact", "")] := "s29";
gotoTable["s2", Var("prod", "")] := "s31";
gotoTable["s3", Var("expr", "")] := "s17";
gotoTable["s3", Var("fact", "")] := "s29";
gotoTable["s3", Var("prod", "")] := "s31";
gotoTable["s4", Var("fact", "")] := "s29";
gotoTable["s4", Var("prod", "")] := "s22";
gotoTable["s5", Var("fact", "")] := "s29";
gotoTable["s5", Var("prod", "")] := "s24";
gotoTable["s6", Var("fact", "")] := "s33";
gotoTable["s7", Var("fact", "")] := "s35";
gotoTable["s8", Var("fact", "")] := "s37";
gotoTable["s9", Var("fact", "")] := "s30";
gotoTable["s9", Var("prod", "")] := "s23";
gotoTable["s10", Var("fact", "")] := "s30";
gotoTable["s10", Var("prod", "")] := "s25";
gotoTable["s11", Var("fact", "")] := "s34";
gotoTable["s12", Var("fact", "")] := "s36";
gotoTable["s13", Var("fact", "")] := "s38";
tokenlist: [["1", "INTEGER"], ["+", "PLUS"], ["2", "INTEGER"], ["*", "TIMES"], ["3", "INTEGER"], ["-", "MINUS"], ["4", "INTEGER"], [";", "SEMICOLON"], ["1", "INTEGER"], ["+", "PLUS"], ["2", "INTEGER"], ["+", "PLUS"], ["3", "INTEGER"], ["+", "PLUS"], ["4", "INTEGER"], [";", "SEMICOLON"], ["1", "INTEGER"], ["+", "PLUS"], ["(", "LPAREN"], ["2", "INTEGER"], ["*", "TIMES"], ["3", "INTEGER"], [")", "RPAREN"], ["*", "TIMES"], ["5", "INTEGER"], ["%", "MOD"], ["6", "INTEGER"], [";", "SEMICOLON"]]

#startState : 1
startState : s0
token_list :{"n"}
states:  [ s0 ]
symbols:  | INTEGER PLUS INTEGER TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr_list", "") -> (*): {\$}Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("S", "") -> (*) arith_expr: {\$}Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }Var("arith_expr", "") -> (*) expr_list:esl: {\$}Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s15 ]
symbols: Token("INTEGER", "n") | PLUS INTEGER TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s30 ]
symbols: Var("fact", "") | PLUS INTEGER TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s32 ]
symbols: Var("prod", "") | PLUS INTEGER TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r6 : Var("expr", "") -> Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s21 ]
symbols: Var("expr", "") | PLUS INTEGER TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s10
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }

token_list :{"n"}
states:  [ s0, s21, s10 ]
symbols: Var("expr", "") Token("PLUS", "") | INTEGER TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s21, s10, s15 ]
symbols: Var("expr", "") Token("PLUS", "") Token("INTEGER", "n") | TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s21, s10, s30 ]
symbols: Var("expr", "") Token("PLUS", "") Var("fact", "") | TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

token_list :{""}
states:  [ s0, s21, s10, s25 ]
symbols: Var("expr", "") Token("PLUS", "") Var("prod", "") | TIMES INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
shifting state s13
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p TIMES (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

token_list :{"n"}
states:  [ s0, s21, s10, s25, s13 ]
symbols: Var("expr", "") Token("PLUS", "") Var("prod", "") Token("TIMES", "") | INTEGER MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p TIMES (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s21, s10, s25, s13, s15 ]
symbols: Var("expr", "") Token("PLUS", "") Var("prod", "") Token("TIMES", "") Token("INTEGER", "n") | MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s21, s10, s25, s13, s38 ]
symbols: Var("expr", "") Token("PLUS", "") Var("prod", "") Token("TIMES", "") Var("fact", "") | MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r7 : Var("prod", "") -> Var("prod", "p") Token("TIMES", "") Var("fact", "f")
stateString : {Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s21, s10, s25 ]
symbols: Var("expr", "") Token("PLUS", "") Var("prod", "") | MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r4 : Var("expr", "") -> Var("expr", "e") Token("PLUS", "") Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s21 ]
symbols: Var("expr", "") | MINUS INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s9
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e MINUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }

token_list :{"n"}
states:  [ s0, s21, s9 ]
symbols: Var("expr", "") Token("MINUS", "") | INTEGER SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e MINUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s21, s9, s15 ]
symbols: Var("expr", "") Token("MINUS", "") Token("INTEGER", "n") | SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s21, s9, s30 ]
symbols: Var("expr", "") Token("MINUS", "") Var("fact", "") | SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> expr:e MINUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e MINUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s21, s9, s23 ]
symbols: Var("expr", "") Token("MINUS", "") Var("prod", "") | SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e MINUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r5 : Var("expr", "") -> Var("expr", "e") Token("MINUS", "") Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s21 ]
symbols: Var("expr", "") | SEMICOLON INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s26
state:   { Var("expr_part", "") -> expr:e SEMICOLON (*): {\$, INTEGER, LPAREN, } }

states:  [ s0, s21, s26 ]
symbols: Var("expr", "") Token("SEMICOLON", "") | INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr_part", "") -> expr:e SEMICOLON (*): {\$, INTEGER, LPAREN, } }
reducing with rule r3 : Var("expr_part", "") -> Var("expr", "e") Token("SEMICOLON", "")
stateString : {Var("expr_list", "") -> (*): {\$}, Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }, Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$}}
var_id : {"part"}
var_id : {"part"}
state:   { Var("expr_list", "") -> (*): {\$}Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$} }

token_list :{"n"}
states:  [ s0, s1 ]
symbols: Var("expr_part", "") | INTEGER PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr_list", "") -> (*): {\$}Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$} }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s15 ]
symbols: Var("expr_part", "") Token("INTEGER", "n") | PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s30 ]
symbols: Var("expr_part", "") Var("fact", "") | PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s32 ]
symbols: Var("expr_part", "") Var("prod", "") | PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r6 : Var("expr", "") -> Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s1, s21 ]
symbols: Var("expr_part", "") Var("expr", "") | PLUS INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s10
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }

token_list :{"n"}
states:  [ s0, s1, s21, s10 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") | INTEGER PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s15 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("INTEGER", "n") | PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s30 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("fact", "") | PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s25 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") | PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r4 : Var("expr", "") -> Var("expr", "e") Token("PLUS", "") Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s1, s21 ]
symbols: Var("expr_part", "") Var("expr", "") | PLUS INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s10
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }

token_list :{"n"}
states:  [ s0, s1, s21, s10 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") | INTEGER PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s15 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("INTEGER", "n") | PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s30 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("fact", "") | PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s25 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") | PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r4 : Var("expr", "") -> Var("expr", "e") Token("PLUS", "") Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s1, s21 ]
symbols: Var("expr_part", "") Var("expr", "") | PLUS INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s10
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }

token_list :{"n"}
states:  [ s0, s1, s21, s10 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") | INTEGER SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s15 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("INTEGER", "n") | SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s30 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("fact", "") | SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s21, s10, s25 ]
symbols: Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") | SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r4 : Var("expr", "") -> Var("expr", "e") Token("PLUS", "") Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s1, s21 ]
symbols: Var("expr_part", "") Var("expr", "") | SEMICOLON INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s26
state:   { Var("expr_part", "") -> expr:e SEMICOLON (*): {\$, INTEGER, LPAREN, } }

states:  [ s0, s1, s21, s26 ]
symbols: Var("expr_part", "") Var("expr", "") Token("SEMICOLON", "") | INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr_part", "") -> expr:e SEMICOLON (*): {\$, INTEGER, LPAREN, } }
reducing with rule r3 : Var("expr_part", "") -> Var("expr", "e") Token("SEMICOLON", "")
stateString : {Var("expr_list", "") -> (*): {\$}, Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }, Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$}}
var_id : {"part"}
var_id : {"part"}
state:   { Var("expr_list", "") -> (*): {\$}Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$} }

token_list :{"n"}
states:  [ s0, s1, s1 ]
symbols: Var("expr_part", "") Var("expr_part", "") | INTEGER PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr_list", "") -> (*): {\$}Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$} }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s15 ]
symbols: Var("expr_part", "") Var("expr_part", "") Token("INTEGER", "n") | PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s30 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("fact", "") | PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s32 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("prod", "") | PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r6 : Var("expr", "") -> Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s1, s1, s21 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") | PLUS LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s10
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }

token_list :{""}
states:  [ s0, s1, s1, s21, s10 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") | LPAREN INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e PLUS (*) prod:p: {MINUS, PLUS, SEMICOLON, } }
shifting state s3
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, RPAREN, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, RPAREN, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, RPAREN, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("fact", "") -> LPAREN (*) expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

token_list :{"n"}
states:  [ s0, s1, s1, s21, s10, s3 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") | INTEGER TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, RPAREN, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, RPAREN, }Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, RPAREN, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("fact", "") -> LPAREN (*) expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
shifting state s14
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s3, s14 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Token("INTEGER", "n") | TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s3, s29 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Var("fact", "") | TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> prod:p (*): {MINUS, PLUS, RPAREN, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, RPAREN, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }

token_list :{""}
states:  [ s0, s1, s1, s21, s10, s3, s31 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Var("prod", "") | TIMES INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, RPAREN, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }
shifting state s8
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p TIMES (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }

token_list :{"n"}
states:  [ s0, s1, s1, s21, s10, s3, s31, s8 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Var("prod", "") Token("TIMES", "") | INTEGER RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p TIMES (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }
shifting state s14
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s3, s31, s8, s14 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Var("prod", "") Token("TIMES", "") Token("INTEGER", "n") | RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s3, s31, s8, s37 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Var("prod", "") Token("TIMES", "") Var("fact", "") | RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }
reducing with rule r7 : Var("prod", "") -> Var("prod", "p") Token("TIMES", "") Var("fact", "f")
stateString : {Var("expr", "") -> prod:p (*): {MINUS, PLUS, RPAREN, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, RPAREN, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s3, s31 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Var("prod", "") | RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> prod:p (*): {MINUS, PLUS, RPAREN, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, RPAREN, TIMES, } }
reducing with rule r6 : Var("expr", "") -> Var("prod", "p")
stateString : {Var("fact", "") -> LPAREN expr:e_part (*) RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, RPAREN, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, RPAREN, }}
var_id : {"e_part"}
var_id : {"e_part"}
state:   { Var("fact", "") -> LPAREN expr:e_part (*) RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, RPAREN, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, RPAREN, } }

token_list :{""}
states:  [ s0, s1, s1, s21, s10, s3, s17 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Var("expr", "") | RPAREN TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> LPAREN expr:e_part (*) RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, RPAREN, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, RPAREN, } }
shifting state s19
state:   { Var("fact", "") -> LPAREN expr:e_part RPAREN (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s3, s17, s19 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Token("LPAREN", "") Var("expr", "") Token("RPAREN", "") | TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> LPAREN expr:e_part RPAREN (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r11 : Var("fact", "") -> Token("LPAREN", "") Var("expr", "e_part") Token("RPAREN", "")
stateString : {Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s30 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("fact", "") | TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r10 : Var("prod", "") -> Var("fact", "f")
stateString : {Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

token_list :{""}
states:  [ s0, s1, s1, s21, s10, s25 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") | TIMES INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
shifting state s13
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p TIMES (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

token_list :{"n"}
states:  [ s0, s1, s1, s21, s10, s25, s13 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") Token("TIMES", "") | INTEGER MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p TIMES (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s25, s13, s15 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") Token("TIMES", "") Token("INTEGER", "n") | MOD INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s25, s13, s38 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") Token("TIMES", "") Var("fact", "") | MOD INTEGER SEMICOLON "$"
state:   { Var("prod", "") -> prod:p TIMES fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r7 : Var("prod", "") -> Var("prod", "p") Token("TIMES", "") Var("fact", "f")
stateString : {Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

token_list :{""}
states:  [ s0, s1, s1, s21, s10, s25 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") | MOD INTEGER SEMICOLON "$"
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
shifting state s12
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p MOD (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

token_list :{"n"}
states:  [ s0, s1, s1, s21, s10, s25, s12 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") Token("MOD", "") | INTEGER SEMICOLON "$"
state:   { Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p MOD (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
shifting state s15
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s25, s12, s15 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") Token("MOD", "") Token("INTEGER", "n") | SEMICOLON "$"
state:   { Var("fact", "") -> INTEGER:n (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r12 : Var("fact", "") -> Token("INTEGER", "n")
stateString : {Var("prod", "") -> prod:p MOD fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"f"}
var_id : {"f"}
state:   { Var("prod", "") -> prod:p MOD fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s25, s12, s36 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") Token("MOD", "") Var("fact", "") | SEMICOLON "$"
state:   { Var("prod", "") -> prod:p MOD fact:f (*): {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r9 : Var("prod", "") -> Var("prod", "p") Token("MOD", "") Var("fact", "f")
stateString : {Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }}
var_id : {"p"}
var_id : {"p"}
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }

states:  [ s0, s1, s1, s21, s10, s25 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("PLUS", "") Var("prod", "") | SEMICOLON "$"
state:   { Var("expr", "") -> expr:e PLUS prod:p (*): {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> prod:p (*) DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> prod:p (*) TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, } }
reducing with rule r4 : Var("expr", "") -> Var("expr", "e") Token("PLUS", "") Var("prod", "p")
stateString : {Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, }}
var_id : {"e"}
var_id : {"e"}
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }

token_list :{""}
states:  [ s0, s1, s1, s21 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") | SEMICOLON "$"
state:   { Var("expr", "") -> expr:e (*) MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> expr:e (*) PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> expr:e (*) SEMICOLON: {\$, INTEGER, LPAREN, } }
shifting state s26
state:   { Var("expr_part", "") -> expr:e SEMICOLON (*): {\$, INTEGER, LPAREN, } }

states:  [ s0, s1, s1, s21, s26 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr", "") Token("SEMICOLON", "") | "$"
state:   { Var("expr_part", "") -> expr:e SEMICOLON (*): {\$, INTEGER, LPAREN, } }
reducing with rule r3 : Var("expr_part", "") -> Var("expr", "e") Token("SEMICOLON", "")
stateString : {Var("expr_list", "") -> (*): {\$}, Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }, Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }, Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}, Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }, Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }, Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$}}
var_id : {"part"}
var_id : {"part"}
state:   { Var("expr_list", "") -> (*): {\$}Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$} }

states:  [ s0, s1, s1, s1 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr_part", "") | "$"
state:   { Var("expr_list", "") -> (*): {\$}Var("fact", "") -> (*) INTEGER:n: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("fact", "") -> (*) LPAREN expr:e_part RPAREN: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) expr:e MINUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr", "") -> (*) expr:e PLUS prod:p: {MINUS, PLUS, SEMICOLON, }Var("expr_part", "") -> (*) expr:e SEMICOLON: {\$, INTEGER, LPAREN, }Var("expr_list", "") -> (*) expr_part:part expr_list:l: {\$}Var("prod", "") -> (*) fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr", "") -> (*) prod:p: {MINUS, PLUS, SEMICOLON, }Var("prod", "") -> (*) prod:p DIVIDE fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p MOD fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("prod", "") -> (*) prod:p TIMES fact:f: {DIVIDE, MINUS, MOD, PLUS, SEMICOLON, TIMES, }Var("expr_list", "") -> expr_part:part (*) expr_list:l: {\$} }
reducing with rule r2 : Var("expr_list", "") -> 
stateString : {Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$}}
var_id : {"l"}
var_id : {"l"}
state:   { Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$} }

states:  [ s0, s1, s1, s1, s28 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr_part", "") Var("expr_list", "") | "$"
state:   { Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$} }
reducing with rule r1 : Var("expr_list", "") -> Var("expr_part", "part") Var("expr_list", "l")
stateString : {Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$}}
var_id : {"l"}
var_id : {"l"}
state:   { Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$} }

states:  [ s0, s1, s1, s28 ]
symbols: Var("expr_part", "") Var("expr_part", "") Var("expr_list", "") | "$"
state:   { Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$} }
reducing with rule r1 : Var("expr_list", "") -> Var("expr_part", "part") Var("expr_list", "l")
stateString : {Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$}}
var_id : {"l"}
var_id : {"l"}
state:   { Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$} }

states:  [ s0, s1, s28 ]
symbols: Var("expr_part", "") Var("expr_list", "") | "$"
state:   { Var("expr_list", "") -> expr_part:part expr_list:l (*): {\$} }
reducing with rule r1 : Var("expr_list", "") -> Var("expr_part", "part") Var("expr_list", "l")
stateString : {Var("arith_expr", "") -> expr_list:esl (*): {\$}}
var_id : {"esl"}
var_id : {"esl"}
state:   { Var("arith_expr", "") -> expr_list:esl (*): {\$} }

states:  [ s0, s27 ]
symbols: Var("expr_list", "") | "$"
state:   { Var("arith_expr", "") -> expr_list:esl (*): {\$} }
reducing with rule r0 : Var("arith_expr", "") -> Var("expr_list", "esl")
stateString : {Var("S", "") -> arith_expr (*): {\$}}
var_id : {}
state:   { Var("S", "") -> arith_expr (*): {\$} }

states:  [ s0, s20 ]
symbols: Var("arith_expr", "") | "$"
state:   { Var("S", "") -> arith_expr (*): {\$} }
accepting

Parse successful!
ast := ExprList([Minus(Plus(Integer(1), Times(Integer(2), Integer(3))), Integer(4)), Plus(Plus(Plus(Integer(1), Integer(2)), Integer(3)), Integer(4)), Plus(Integer(1), Mod(Times(Times(Integer(2), Integer(3)), Integer(5)), Integer(6)))])
