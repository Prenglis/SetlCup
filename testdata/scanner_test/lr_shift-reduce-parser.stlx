class srParser(actionTable, gotoTable, stateTable, rulesMap) {
    mActionTable := actionTable;
    mGotoTable   := gotoTable;
    mStateTable  := stateTable;
    mRulesMap := rulesMap;

    parseSR := procedure(tl) {
        index   := 1;      // point to next token
        symbols := [];     // stack of symbols
        // print("mStateTable[s7] : $mStateTable[\"s7\"]$");
        // m := matches(mStateTable["s7"], '.*Var\("S", ""\) -> \(\*\)');
        // print("matches : $m$");
        startState := { x : x in domain(mStateTable) | matches(mStateTable[x], '.*Var\("S", ""\) -> \(\*\)')};
        print("#startState : $#startState$");
        assert(#startState == 1, "multiple States contain S -> (*)");
        startState := arb(startState);
        print("startState : $startState$");
        states  := [startState]; // stack of states, 0 is start state
        symbolMapStack := [{["result", om]}];
        while (true) {
            symbolMap := symbolMapStack[-1];            
            q := states[-1];
            [t_value, t] := tl[index];
            token_list := {args(t_token)[2] : [t_states, t_token ] in domain(mActionTable) | t_states == q && args(t_token)[1] == t};
            assert(#token_list == 1, "Only 1 Possible Action for Token in State");
            token_id := arb(token_list);
            t := Token(t, token_id);
            if(token_id != "")
            {
                symbolMap[token_id] := t_value;
            }
            t_rest := [ y : [x,y] in tl[index..]];
            print("states:  [ $join(states, \", \")$ ]");
            print("symbols: $join(symbols, \" \")$ | $join(t_rest, \" \")$");
            print("state:   { $join(mStateTable[q], \"\")$ }");
            p := mActionTable[q,t];
            match (p) {
            case om: 
                 print("action($q$, $t$) undefined.");
                 print("Syntax error!\n");
                 return false;
            case Shift(s):
                 print("shifting state $s$");
                 print("state:   { $join(mStateTable[s], \"\")$ }\n");
                 symbolMapStack := symbolMapStack + [symbolMap];
                 symbols := symbols + [t];
                 states  := states  + [s];
                 index   += 1;
            case Reduce(ruleName):
                 // print("reducing with rule $ruleName$");
                 // evalro := eval("r0");
                 // print("eval(\"r0\") : $evalro$");
                 // print("ro : $r0$");
                 // rule := eval("$ruleName$");
                 rule := mRulesMap[ruleName];

                 // print("reduc rule : $rule$");

                 // ruleNumber := 
                 // rule := rules[m];
                 head := args(rule)[1];
                 body := args(rule)[2];

                 
                 print("reducing with rule $ruleName$ : $head$ -> $join(body, \" \")$");
                 n       := #body;
                 symbols := symbols[.. -(n+1)];
                 states  := states[.. -(n+1)]; 
                 symbols := symbols + [head];
                 state   := states[-1];
                 // print("state, head : $state$ , $head$");
                 // print("mGotoTable : $mGotoTable$");
                 // print("s7 : $mGotoTable[state, head]$");
                 states  := states + [ mGotoTable[state, head] ];
                 print("state:   { $join(mStateTable[mGotoTable[state, head]], \"\")$ }\n");
            case Accept():
                 print("accepting\n");
                 return true;
            } 
        }
    };
}

load("lr_parse_table.stlx");
// print(rulesMap);
// load("parse-table.stlx");

myParse := closure(s) {
    parser := srParser(actionTable, gotoTable, stateTable, rulesMap);
    // tl := tokenizeString(s);
    tl := scan_output;
    print("tokenlist: $tl$\n");
    if (parser.parseSR(tl + [[@"$", '$']])) {
        print("Parse successful!");
    } else {
        print("Parse failed!");
    }
};

// This procedure partitions the string s into a list of tokens.
// It recognizes numbers, the operator symbols "+", "-", "*", "/", "**"
// and the parentheses "(" and ")".
tokenizeString := procedure(s) {
    tokenList := [];
    scan (s) {
        regex '0|[1-9][0-9]*' as [ number   ]: tokenList += [ "int"    ];
        regex '[-+*/()]'      as [ operator ]: tokenList += [ operator ];
        regex '[ \t\v\n\r]+'                 : // skip
    }
    return tokenList;
};

myParse(" 1 + 2 * 3;");
