class srParser(actionTable, gotoTable, stateTable, rulesMap, silent_mode) {
    mActionTable := actionTable;
    mGotoTable   := gotoTable;
    mStateTable  := stateTable;
    mRulesMap := rulesMap;
    mSilentMode := silent_mode;
    parseSR := procedure(tl) {
        action_code := [];
        index   := 1;      // point to next token
        symbols := [];     // stack of symbols
        // print("mStateTable[s7] : $mStateTable[\"s7\"]$");
        // m := matches(mStateTable["s7"], '.*Var\("S", ""\) -> \(\*\)');
        // print("matches : $m$");
        // startState := { x : x in domain(mStateTable) | matches(mStateTable[x], '.*Var\("S", ""\) -> \(\*\)')};
        startState := {x : x in domain(mStateTable) | exists(y in mStateTable[x]| y.mVariable == Var("S", "") && y.mAlpha == [])};
        // print("#startState : $#startState$");
        if(!mSilentMode)
        {
            print("#startState : $#startState$");
        }
        assert(#startState == 1, "multiple States contain S -> (*)");
        startState := arb(startState);
        if(!mSilentMode)
        {
            print("startState : $startState$");
        }
        states  := [startState]; // stack of states, 0 is start state
        // symbolMapStack := [{["result", om]}];
        // print("mActionTable : $mActionTable$");
        while (true) {
            // symbolMap := symbolMapStack[-1];            
            q := states[-1];
            [t_value, t] := tl[index];
            token_id := "";
            // print("[t_value, t] = $[t_value, t]$");
            // print("mStateTable := $mStateTable$;");
            action_tokens := { [args(t_token)[2], mStateTable[shiftState]] : [t_states, t_token ] in domain(mActionTable), shiftState in mActionTable[t_states, t_token] | t_states == q && args(t_token)[1] == t };
            // action_tokens := {[token_list, {x : x in matches("$followTokens$", '.*\(\*\) ([a-zA-Z][a-zA-Z_0-9]*)', true)}] : [token_list, followTokens] in action_tokens};
             // for([token_list, followTokens] in action_tokens)
             // {
                  print("action_tokens : $action_tokens$");
            // }
            if(#action_tokens > 0 && #arb(action_tokens)>1)
            {
                action_tokens := {[token_list, { args(x.mBeta[1])[1] : x in followTokens | x.mBeta != []}] : [token_list, followTokens] in action_tokens};
            }
                 print("action_tokens : $action_tokens$");
            // action_tokens := {[token_list, "$followTokens$"] : [token_list, followTokens] in action_tokens};
            if(isMap(action_tokens))
            {
                token_list := domain(action_tokens);
                if(#token_list>0)
                {
                    // print("token_list : $token_list$");
                    if(#token_list > 1)
                    {
                        // print("token_list : $token_list$");
                        // print("t_rest : $t_rest$");
                        // print("action_tokens : $action_tokens$");
                        // for(ts in action_tokens)
                        // {
                            // print("ts[2] : $ts[2]$");
                            // m := matches("'$ts[2]$'", '.*\(\*\) [a-zA-Z][a-zA-Z_0-9]*');
                            // print ("m : $m$");
                            // m := matches("'$ts[2]$'", '.*\(\*\) ([a-zA-Z][a-zA-Z_0-9]*)', true);
                            // print ("m : $m$");
                        // }
                        token_list := [x : [x, ft] in action_tokens | (ft * {tl[index+1][2]} != {}) ];
                        if(#token_list == 0)
                        {
                            token_list := [x : [x, ft] in action_tokens | (ft * {tl[index+1][2]} == {} && ft =={})];
                        }
                        // print("index : $index$ , tl[index+1] : $tl[index+1][2]$");
                        // print("token_list : $token_list$");
                    } 
                    if(!mSilentMode)
                    {
                        print("token_list :$token_list$");               
                    }
                    assert(#token_list == 1, "Only one Possible Action for Token in State");
                    token_id := arb(token_list);                
                    if(token_id != "")
                    {
                        // symbolMap[token_id] := t_value;
                        // print("t_value : $t_value$");
                        // if(isString(t_value))
                        // if(t == "STRING" || t == "ID" || t == "VAR" || t =="ZID")
                        // {
                            action_code := action_code + ["$token_id$ := '$t_value$';"];
                        // }
                        // else
                        // {
                            // action_code := action_code + ["$token_id$ := $t_value$;"];
                        // }
                    }
                }
            }
            t := Token(t, token_id);             
            t_rest := [ y : [x,y] in tl[index..]];
            if(!mSilentMode)
            {
                print("states:  [ $join(states, \", \")$ ]");
                print("symbols: $join(symbols, \" \")$ | $join(t_rest, \" \")$");
                print("state:   { $join(mStateTable[q], \"\")$ }");
            }
            p := mActionTable[q,t];
            match (p) {
            case om: 
                if(!mSilentMode)
                {
                     print("action($q$, $t$) undefined.");
                     print("Syntax error!\n");
                }
                 return false;
            case Shift(s):
                if(!mSilentMode)
                {
                     print("shifting state $s$");
                     print("state:   { $join(mStateTable[s], \"\")$ }\n");
                }
                 // symbolMapStack := symbolMapStack + [symbolMap];

                 symbols := symbols + [t];
                 states  := states  + [s];
                 index   += 1;
            case Reduce(ruleName):
                 // print("reducing with rule $ruleName$");
                 // evalro := eval("r0");
                 // print("eval(\"r0\") : $evalro$");
                 // print("ro : $r0$");
                 // rule := eval("$ruleName$");
                 rule := mRulesMap[ruleName];

                 // print("reduc rule : $rule$");

                 // ruleNumber := 
                 // rule := rules[m];
                 // head := args(rule)[1];
                 // body := args(rule)[2];
                 [head, body , user_code] := args(rule);

                 if(!mSilentMode)
                {
                    print("reducing with rule $ruleName$ : $head$ -> $join(body, \" \")$");
                }
                 action_code := action_code + [args(user_code)[1]];
                 n       := #body;
                 symbols := symbols[.. -(n+1)];
                 states  := states[.. -(n+1)]; 
                 symbols := symbols + [head];
                 state   := states[-1];
                 // print("state, head : $state$ , $head$");
                 // print("mGotoTable : $mGotoTable$");
                 // print("s7 : $mGotoTable[state, head]$");
                 newStates := mGotoTable[state, head];
                 states  := states + [ newStates ];
                 stateString := mStateTable[newStates];
                 
                 // var_id := matches(stateString, ".*$args(head)[1]$:([a-z][a-zA-Z_0-9]*) \\(\\*\\)", true)[2..];
                 print("mStateTable[$newStates$] : $mStateTable[newStates]$");
                 // for(mr in mStateTable[newStates])
                 // {
                    // print("alpha : $mr.mAlpha$");
                 // }
                 var_id := [];
                 if(mStateTable[newStates] != om)
                    {
                        var_id := [args(mr.mAlpha[-1])[2] : mr in mStateTable[newStates]| mr.mAlpha != [] && ( args(mr.mAlpha[-1])[1] == args(head)[1])];
                    }
                 if(!mSilentMode)
                {
                    print("stateString : $stateString$");
                    print("var_id : $var_id$");
                }
                 if(#var_id > 0)
                 {
                    var_id := { x :  x in var_id};
                    assert(#var_id ==1, "only one variable id should be used for one reduction");
                    if(!mSilentMode)
                    {
                        print("var_id : $var_id$");
                    }
                    action_code := action_code + ["$arb(var_id)$ := result;"];
                 }
                 if(!mSilentMode)
                 {  
                    print("state:   { $join(mStateTable[mGotoTable[state, head]], \"\")$ }\n");
                }
            case Accept():
                 if(!mSilentMode)
                 { 
                    print("accepting\n");
                    }
                 writeFile("output\\action_code.stlx", action_code);

                 return true;
            } 
        }
    };
}

// load("output\\lr_parse_table.stlx");
// print(rulesMap);
// load("parse-table.stlx");

myParse := closure(ruleNames, rulesMap, stateTable, actionTable, gotoTable, silent_mode) {
    parser := srParser(actionTable, gotoTable, stateTable, rulesMap, silent_mode);
    // tl := tokenizeString(s);
    tl := scan_output;
    if(!silent_mode)
    {
        print("tokenlist: $tl$\n");
    }
    if (parser.parseSR(tl + [[@"$", @"$"]])) {
        print("Parse successful!");
    } else {
        // print("mActionTable: $actionTable$");
        print("Parse failed!");
    }
};

// This procedure partitions the string s into a list of tokens.
// It recognizes numbers, the operator symbols "+", "-", "*", "/", "**"
// and the parentheses "(" and ")".
tokenizeString := procedure(s) {
    tokenList := [];
    scan (s) {
        regex '0|[1-9][0-9]*' as [ number   ]: tokenList += [ "int"    ];
        regex '[-+*/()]'      as [ operator ]: tokenList += [ operator ];
        regex '[ \t\v\n\r]+'                 : // skip
    }
    return tokenList;
};
