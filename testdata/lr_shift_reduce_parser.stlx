class srParser(actionTable, gotoTable, stateTable, rulesMap, silent_mode) {
    mActionTable := actionTable;
    mGotoTable   := gotoTable;
    mStateTable  := stateTable;
    mRulesMap := rulesMap;
    mSilentMode := silent_mode;
    parseSR := procedure(tl) {
        action_code := [];
        index   := 1;      // point to next token
        symbols := [];     // stack of symbols
        // print("mStateTable[s7] : $mStateTable[\"s7\"]$");
        // m := matches(mStateTable["s7"], '.*Var\("S", ""\) -> \(\*\)');
        // print("matches : $m$");
        startState := { x : x in domain(mStateTable) | matches(mStateTable[x], '.*Var\("S", ""\) -> \(\*\)')};
        if(!mSilentMode)
        {
            print("#startState : $#startState$");
        }
        assert(#startState == 1, "multiple States contain S -> (*)");
        startState := arb(startState);
        if(!mSilentMode)
        {
            print("startState : $startState$");
        }
        states  := [startState]; // stack of states, 0 is start state
        symbolMapStack := [{["result", om]}];
        while (true) {
            symbolMap := symbolMapStack[-1];            
            q := states[-1];
            [t_value, t] := tl[index];
            token_id := "";
            // print("[t_value, t] = $[t_value, t]$");
            action_tokens := { [args(t_token)[2], {mStateTable[shiftState]}] : [t_states, t_token ] in domain(mActionTable), shiftState in mActionTable[t_states, t_token] | t_states == q && args(t_token)[1] == t };
            action_tokens := {[token_list, {x : x in matches("$followTokens$", '.*\(\*\) ([a-zA-Z][a-zA-Z_0-9]*)', true)}] : [token_list, followTokens] in action_tokens};
            // action_tokens := {[token_list, "$followTokens$"] : [token_list, followTokens] in action_tokens};
            token_list := domain(action_tokens);
            if(#token_list>0)
            {
                // print("token_list : $token_list$");
                if(#token_list > 1)
                {
                    // print("token_list : $token_list$");
                    // print("t_rest : $t_rest$");
                    // print("action_tokens : $action_tokens$");
                    // for(ts in action_tokens)
                    // {
                        // print("ts[2] : $ts[2]$");
                        // m := matches("'$ts[2]$'", '.*\(\*\) [a-zA-Z][a-zA-Z_0-9]*');
                        // print ("m : $m$");
                        // m := matches("'$ts[2]$'", '.*\(\*\) ([a-zA-Z][a-zA-Z_0-9]*)', true);
                        // print ("m : $m$");
                    // }
                    token_list := [x : [x, ft] in action_tokens | (ft * {tl[index+1][2]} != {}) ];
                    if(#token_list == 0)
                    {
                        token_list := [x : [x, ft] in action_tokens | (ft * {tl[index+1][2]} == {} && ft =={})];
                    }
                    // print("index : $index$ , tl[index+1] : $tl[index+1][2]$");
                    // print("token_list : $token_list$");
                } 
                if(!mSilentMode)
                {
                    print("token_list :$token_list$");               
                }
                assert(#token_list == 1, "Only one Possible Action for Token in State");
                token_id := arb(token_list);                
                if(token_id != "")
                {
                    // symbolMap[token_id] := t_value;
                    // print("t_value : $t_value$");
                    // if(isString(t_value))
                    // if(t == "STRING" || t == "ID" || t == "VAR" || t =="ZID")
                    // {
                        action_code := action_code + ["$token_id$ := '$t_value$';"];
                    // }
                    // else
                    // {
                        // action_code := action_code + ["$token_id$ := $t_value$;"];
                    // }
                }
            }
            t := Token(t, token_id);             
            t_rest := [ y : [x,y] in tl[index..]];
            if(!mSilentMode)
            {
                print("states:  [ $join(states, \", \")$ ]");
                print("symbols: $join(symbols, \" \")$ | $join(t_rest, \" \")$");
                print("state:   { $join(mStateTable[q], \"\")$ }");
            }
            p := mActionTable[q,t];
            match (p) {
            case om: 
                if(!mSilentMode)
                {
                     print("action($q$, $t$) undefined.");
                     print("Syntax error!\n");
                }
                 return false;
            case Shift(s):
                if(!mSilentMode)
                {
                     print("shifting state $s$");
                     print("state:   { $join(mStateTable[s], \"\")$ }\n");
                }
                 // symbolMapStack := symbolMapStack + [symbolMap];

                 symbols := symbols + [t];
                 states  := states  + [s];
                 index   += 1;
            case Reduce(ruleName):
                 // print("reducing with rule $ruleName$");
                 // evalro := eval("r0");
                 // print("eval(\"r0\") : $evalro$");
                 // print("ro : $r0$");
                 // rule := eval("$ruleName$");
                 rule := mRulesMap[ruleName];

                 // print("reduc rule : $rule$");

                 // ruleNumber := 
                 // rule := rules[m];
                 // head := args(rule)[1];
                 // body := args(rule)[2];
                 [head, body , user_code] := args(rule);

                 if(!mSilentMode)
                {
                    print("reducing with rule $ruleName$ : $head$ -> $join(body, \" \")$");
                }
                 action_code := action_code + [args(user_code)[1]];
                 n       := #body;
                 symbols := symbols[.. -(n+1)];
                 states  := states[.. -(n+1)]; 
                 symbols := symbols + [head];
                 state   := states[-1];
                 // print("state, head : $state$ , $head$");
                 // print("mGotoTable : $mGotoTable$");
                 // print("s7 : $mGotoTable[state, head]$");
                 newStates := mGotoTable[state, head];
                 states  := states + [ newStates ];
                 stateString := mStateTable[newStates];
                 
                 var_id := matches(stateString, ".*$args(head)[1]$:([a-z][a-zA-Z_0-9]*) \\(\\*\\)", true)[2..];
                 if(!mSilentMode)
                {
                    print("stateString : $stateString$");
                    print("var_id : $var_id$");
                }
                 if(#var_id > 0)
                 {
                    var_id := { x :  x in var_id};
                    assert(#var_id ==1, "only one variable id should be used for one reduction");
                    if(!mSilentMode)
                    {
                        print("var_id : $var_id$");
                    }
                    action_code := action_code + ["$arb(var_id)$ := result;"];
                 }
                 if(!mSilentMode)
                 {  
                    print("state:   { $join(mStateTable[mGotoTable[state, head]], \"\")$ }\n");
                }
            case Accept():
                 if(!mSilentMode)
                 { 
                    print("accepting\n");
                    }
                 writeFile("output\\action_code.stlx", action_code);

                 return true;
            } 
        }
    };
}

// load("output\\lr_parse_table.stlx");
// print(rulesMap);
// load("parse-table.stlx");

myParse := closure(ruleNames, rulesMap, stateTable, actionTable, gotoTable, silent_mode) {
    parser := srParser(actionTable, gotoTable, stateTable, rulesMap, silent_mode);
    // tl := tokenizeString(s);
    tl := scan_output;
    if(!silent_mode)
    {
        print("tokenlist: $tl$\n");
    }
    if (parser.parseSR(tl + [[@"$", '$']])) {
        print("Parse successful!");
    } else {
        print("Parse failed!");
    }
};

// This procedure partitions the string s into a list of tokens.
// It recognizes numbers, the operator symbols "+", "-", "*", "/", "**"
// and the parentheses "(" and ")".
tokenizeString := procedure(s) {
    tokenList := [];
    scan (s) {
        regex '0|[1-9][0-9]*' as [ number   ]: tokenList += [ "int"    ];
        regex '[-+*/()]'      as [ operator ]: tokenList += [ operator ];
        regex '[ \t\v\n\r]+'                 : // skip
    }
    return tokenList;
};
